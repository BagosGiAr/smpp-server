h1. SMPP Server

A project based on the "smppapi":http://smppapi.sourceforge.net/ library that accepts client connections and allows you to easily handle SMPP packets.

h2. Starting and stopping

To start the server you need to instantiate the @net.gescobar.smppserver.SmppServer@ class and call the @start()@ method:

<pre><code>
SmppServer server = new SmppServer(4444); // 4444 is the port, change it as needed
server.start();
		
// somewhere else
server.stop();
</code></pre>

h2. Processing SMPP packets

To process SMPP packets, you will need to provide an implementation of the @net.gescobar.smppserver.PacketProcessor@:

<pre><code>
public class MyPacketProcessor implements PacketProcessor {
			
	@Override
	public ResponseStatus processPacket(SMPPPacket packet) {
				
		if (packet.getCommandId() == SMPPPacket.BIND_RECEIVER
	   	 		|| packet.getCommandId() == SMPPPacket.BIND_TRANSCEIVER
	   	 		|| packet.getCommandId() == SMPPPacket.BIND_TRANSMITTER) {
	   	 		
	   	 	// check the credentials and return the corresponding SMPP command status
	   	 	return ResponseStatus.OK;
	   	 					
	   	 } else if (packet.getCommandId() == SMPPPacket.SUBMIT_SM) {
	   	 		
	   	 	// a message has arrived, what do you want to do with it?
	   	 			
	   	 	return ResponseStatus.INVALID_DEST_ADDRESS; // just an example
	   	 		
	   	 }
	}
}
</code></pre> 

You will need to pass your @PacketProcessor@ implementation to the @SmppServer@ using the constructor or the setter method:

<pre><code>
SmppServer server = new SmppServer(4444, new MyPacketProcessor());
		
// or
		
server.setPacketProcessor(new MyPacketProcessor());
</code></pre>

If you don't provide a @PacketProcessor@ implementation, the default one (that always returns @ResponseStatus.OK@) will be used.

That's it! You can start receiving connections now.